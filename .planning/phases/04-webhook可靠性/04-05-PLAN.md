---
phase: 04-webhook可靠性
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/API/WebhookLogAPI.php
  - fluentcart-payuni.php
autonomous: true

must_haves:
  truths:
    - "管理員可透過 REST API 查詢 webhook 處理記錄"
    - "可依 transaction_id 或 trade_no 過濾查詢"
    - "查詢結果可用於除錯重複處理或遺漏問題"
  artifacts:
    - path: "src/API/WebhookLogAPI.php"
      provides: "Webhook 日誌查詢 REST API"
      exports: ["register_routes", "get_logs"]
  key_links:
    - from: "WebhookLogAPI"
      to: "payuni_webhook_log table"
      via: "wpdb queries"
      pattern: "\\$wpdb->.*payuni_webhook_log"
    - from: "fluentcart-payuni.php"
      to: "WebhookLogAPI"
      via: "rest_api_init hook"
      pattern: "WebhookLogAPI.*register_routes"
---

<objective>
建立 Webhook 日誌查詢 API

Purpose: 提供 REST API 讓管理員查詢 webhook 處理記錄，用於除錯重複處理或遺漏問題。滿足 Phase 04 目標「Webhook 日誌可查詢和除錯」。

Output:
- `WebhookLogAPI.php` REST API 端點
- 在主外掛檔案註冊 API 路由
</objective>

<execution_context>
@/Users/fishtv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fishtv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-webhook可靠性/04-01-SUMMARY.md

# 現有 API 實作參考
@src/API/PayUNiAPI.php

# 資料表結構
@includes/class-database.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 建立 WebhookLogAPI 類別</name>
  <files>src/API/WebhookLogAPI.php</files>
  <action>
建立 `src/API/WebhookLogAPI.php`，提供 webhook 日誌查詢功能：

1. **類別結構**：
   ```php
   namespace BuyGoFluentCart\PayUNi\API;

   use FluentcartPayuni\Database;

   /**
    * WebhookLogAPI
    *
    * 白話：提供 REST API 查詢 webhook 處理記錄，用於除錯。
    */
   final class WebhookLogAPI
   {
       private const NAMESPACE = 'fluentcart-payuni/v1';

       public function register_routes(): void
       public function get_logs(\WP_REST_Request $request): \WP_REST_Response
       public function permission_check(): bool
   }
   ```

2. **register_routes() 方法**：
   ```php
   public function register_routes(): void
   {
       register_rest_route(self::NAMESPACE, '/webhook-logs', [
           'methods'             => 'GET',
           'callback'            => [$this, 'get_logs'],
           'permission_callback' => [$this, 'permission_check'],
           'args'                => [
               'transaction_id' => [
                   'type'              => 'string',
                   'sanitize_callback' => 'sanitize_text_field',
               ],
               'trade_no' => [
                   'type'              => 'string',
                   'sanitize_callback' => 'sanitize_text_field',
               ],
               'webhook_type' => [
                   'type'              => 'string',
                   'enum'              => ['notify', 'return'],
                   'sanitize_callback' => 'sanitize_text_field',
               ],
               'per_page' => [
                   'type'    => 'integer',
                   'default' => 20,
                   'minimum' => 1,
                   'maximum' => 100,
               ],
               'page' => [
                   'type'    => 'integer',
                   'default' => 1,
                   'minimum' => 1,
               ],
           ],
       ]);
   }
   ```

3. **get_logs() 方法**：
   ```php
   public function get_logs(\WP_REST_Request $request): \WP_REST_Response
   {
       global $wpdb;

       $table = Database::getWebhookLogTable();
       $per_page = $request->get_param('per_page') ?? 20;
       $page = $request->get_param('page') ?? 1;
       $offset = ($page - 1) * $per_page;

       // 建立查詢條件
       $where = [];
       $values = [];

       if ($transaction_id = $request->get_param('transaction_id')) {
           $where[] = 'transaction_id = %s';
           $values[] = $transaction_id;
       }

       if ($trade_no = $request->get_param('trade_no')) {
           $where[] = 'trade_no = %s';
           $values[] = $trade_no;
       }

       if ($webhook_type = $request->get_param('webhook_type')) {
           $where[] = 'webhook_type = %s';
           $values[] = $webhook_type;
       }

       $where_clause = $where ? 'WHERE ' . implode(' AND ', $where) : '';

       // 計算總數
       $count_sql = "SELECT COUNT(*) FROM {$table} {$where_clause}";
       if ($values) {
           $count_sql = $wpdb->prepare($count_sql, ...$values);
       }
       $total = (int) $wpdb->get_var($count_sql);

       // 取得資料
       $values[] = $per_page;
       $values[] = $offset;
       $sql = "SELECT * FROM {$table} {$where_clause} ORDER BY processed_at DESC LIMIT %d OFFSET %d";
       $sql = $wpdb->prepare($sql, ...$values);
       $logs = $wpdb->get_results($sql, ARRAY_A);

       return new \WP_REST_Response([
           'data'       => $logs,
           'total'      => $total,
           'page'       => $page,
           'per_page'   => $per_page,
           'total_pages' => (int) ceil($total / $per_page),
       ], 200);
   }
   ```

4. **permission_check() 方法**：
   ```php
   public function permission_check(): bool
   {
       // 只允許管理員查詢
       return current_user_can('manage_options');
   }
   ```

5. **注意事項**：
   - 使用 `$wpdb->prepare()` 防止 SQL injection
   - 分頁預設 20 筆，最多 100 筆
   - 只有管理員可以查詢
  </action>
  <verify>
1. PHP 語法檢查：`php -l src/API/WebhookLogAPI.php`
2. 確認類別結構正確
  </verify>
  <done>
`WebhookLogAPI.php` 存在，包含 `register_routes()`, `get_logs()`, `permission_check()` 方法。
  </done>
</task>

<task type="auto">
  <name>Task 2: 在主外掛註冊 API 路由</name>
  <files>fluentcart-payuni.php</files>
  <action>
修改 `fluentcart-payuni.php`，在 `rest_api_init` hook 註冊 WebhookLogAPI：

1. **在 bootstrap 函式中新增 hook**（約在其他 hook 註冊處）：
   ```php
   add_action('rest_api_init', function () {
       $api = new \BuyGoFluentCart\PayUNi\API\WebhookLogAPI();
       $api->register_routes();
   });
   ```

2. **確保 autoloader 可載入**：
   - WebhookLogAPI 應該已經被 Composer autoload 或 PSR-4 載入
   - 如果使用手動 require，新增：
     ```php
     require_once BUYGO_FC_PAYUNI_PATH . 'src/API/WebhookLogAPI.php';
     ```

3. **位置建議**：在現有的 API 註冊（如 PayUNiAPI）附近
  </action>
  <verify>
1. PHP 語法檢查：`php -l fluentcart-payuni.php`
2. 確認有 `rest_api_init` hook 註冊 WebhookLogAPI
  </verify>
  <done>
WebhookLogAPI 路由在 `rest_api_init` hook 中註冊。
  </done>
</task>

<task type="auto">
  <name>Task 3: 驗證 API 可用</name>
  <files>無新檔案</files>
  <action>
驗證 WebhookLogAPI 可正常使用：

1. **確認路由已註冊**：
   - 訪問 `https://test.buygo.me/wp-json/fluentcart-payuni/v1` 應顯示可用端點
   - 或執行：`wp rest api routes --path=/fluentcart-payuni/v1`

2. **測試查詢**（需管理員登入）：
   ```bash
   # 取得所有日誌（前 20 筆）
   curl -X GET "https://test.buygo.me/wp-json/fluentcart-payuni/v1/webhook-logs" \
     -H "Cookie: <admin_cookie>"

   # 依 transaction_id 過濾
   curl -X GET "https://test.buygo.me/wp-json/fluentcart-payuni/v1/webhook-logs?transaction_id=xxx"

   # 依 trade_no 過濾
   curl -X GET "https://test.buygo.me/wp-json/fluentcart-payuni/v1/webhook-logs?trade_no=xxx"
   ```

3. **預期回應格式**：
   ```json
   {
     "data": [
       {
         "id": 1,
         "transaction_id": "uuid-xxx",
         "trade_no": "TN123",
         "webhook_type": "notify",
         "processed_at": "2026-01-29 10:00:00",
         "payload_hash": "sha256..."
       }
     ],
     "total": 1,
     "page": 1,
     "per_page": 20,
     "total_pages": 1
   }
   ```

4. **權限驗證**：
   - 未登入應回傳 401
   - 非管理員應回傳 403
  </action>
  <verify>
1. API 端點可訪問：`/wp-json/fluentcart-payuni/v1/webhook-logs`
2. 管理員可成功查詢
3. 非管理員被拒絕
  </verify>
  <done>
WebhookLogAPI 可正常使用，管理員可查詢 webhook 處理記錄。
  </done>
</task>

</tasks>

<verification>
1. PHP 語法檢查通過：
   ```bash
   php -l src/API/WebhookLogAPI.php
   php -l fluentcart-payuni.php
   ```

2. API 路由存在：
   ```bash
   curl -s "https://test.buygo.me/wp-json/fluentcart-payuni/v1" | grep -c "webhook-logs"
   # 應為 >= 1
   ```

3. 權限控制正常：
   - 管理員可查詢
   - 非管理員被拒絕
</verification>

<success_criteria>
- [ ] WebhookLogAPI.php 存在且語法正確
- [ ] API 路由在 rest_api_init 中註冊
- [ ] `/fluentcart-payuni/v1/webhook-logs` 端點可用
- [ ] 支援 transaction_id、trade_no、webhook_type 過濾
- [ ] 支援分頁（per_page、page）
- [ ] 只有管理員可查詢
</success_criteria>

<output>
After completion, create `.planning/phases/04-webhook可靠性/04-05-SUMMARY.md`
</output>
